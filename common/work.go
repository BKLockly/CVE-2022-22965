package common

import (
	"CVE-2022-22965/util"
	"bufio"
	"fmt"
	"github.com/corpix/uarand"
	"io/ioutil"
	"net/http"
	"os"
	"strings"
	"sync"
	"time"
)

/**
 * @Author $
 * @Description //TODO $
 * @Date $ $
 * @return $
 **/

type Host struct {
	host string
}

type Response struct {
	Status        string
	StatusCode    int
	Body          string
	Header        http.Header
	ContentLength int
	RequestUrl    string
	Location      string
}

func ScanTask(Dict string) (hosts []string) {
	file, err := os.Open(Dict)
	if err != nil {
		util.Log.LogDebug("Open user dict file err: " + err.Error())
	} else {
		util.Log.LogDebug("Open target file successfully!")
	}

	defer file.Close()

	scanner := bufio.NewScanner(file)
	scanner.Split(bufio.ScanLines)

	for scanner.Scan() {
		user := strings.TrimSpace(scanner.Text())
		if user != "" {
			host := fmt.Sprintf("http://%v:8080", user)
			hosts = append(hosts, host)
		}
	}
	util.Log.LogDebug(fmt.Sprintf("Number of all tasks: %v", len(hosts)))
	return hosts
}

func BatchScan(hosts []string, timeout int64, workers int) {
	var wg sync.WaitGroup
	Hosts := make(chan Host, len(hosts))
	result := make(chan string, len(hosts))

	f, err := os.OpenFile("./result.txt", os.O_APPEND|os.O_WRONLY, os.ModeAppend)
	if err != nil {
		util.Log.LogDebug("Log file not exist! Creating result files...")
		_, errC := os.Create("./result.txt")
		if errC != nil {
			util.Log.LogError(fmt.Sprintf("Error creating file: %v", err))
		}

	} else {
		util.Log.LogInfo("Find result log file!")
	}
	defer f.Close()

	go func() {
		for res := range result {
			if _, err := f.WriteString("\t" + res + "\n"); err != nil {
				util.Log.LogError("Error occured in writing files: " + err.Error())
			}
			wg.Done()
		}
	}()

	for i := 0; i < workers; i++ {
		go func() {
			for target := range Hosts {
				util.Log.LogDebug("Start task for " + string(target.host))
				BatchPoc(target.host, timeout, result, &wg)
				wg.Done()
			}
		}()
	}

	for _, host := range hosts {
		wg.Add(1)
		Hosts <- Host{host: host}
	}

	wg.Wait()
	close(Hosts)
	close(result)
}

func HttpRequset(urlstring string, method string, postdata string, timeout int64, headers map[string]string) (*Response, error) {
	client := &http.Client{
		Timeout: time.Duration(timeout) * time.Second,
		CheckRedirect: func(req *http.Request, via []*http.Request) error {
			return http.ErrUseLastResponse
		}}
	req, err := http.NewRequest(strings.ToUpper(method), urlstring, strings.NewReader(postdata))
	if err != nil {
		return nil, err
	}
	if headers["Content-Type"] == "" && headers["Content-type"] == "" {
		req.Header.Set("Content-Type", "application/x-www-form-urlencoded; charset=UTF-8")
	}
	req.Header.Set("User-Agent", uarand.GetRandom())
	for v, k := range headers {
		req.Header[v] = []string{k}
	}
	resp, err := client.Do(req)
	if err != nil {
		//防止空指针
		return &Response{"999", 999, "", nil, 0, "", ""}, err
	}
	var location string
	var reqbody string
	defer resp.Body.Close()
	if body, err := ioutil.ReadAll(resp.Body); err == nil {
		reqbody = string(body)
	}
	if resplocation, err := resp.Location(); err == nil {
		location = resplocation.String()
	}
	return &Response{resp.Status, resp.StatusCode, reqbody, resp.Header, len(reqbody), resp.Request.URL.String(), location}, nil
}
